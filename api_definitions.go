/*
AMPLIFY Central API v0.347

APIs to manage AMPLIFY Central configuration resources.

API version: 0.347.0
Contact: support@axway.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package amplify

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DefinitionsAPIService DefinitionsAPI service
type DefinitionsAPIService service

type ApiCountDefinitionsV1alpha1AccessControlListRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	xAxwayTenantId *string
	query *string
	count *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCountDefinitionsV1alpha1AccessControlListRequest) XAxwayTenantId(xAxwayTenantId string) ApiCountDefinitionsV1alpha1AccessControlListRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiCountDefinitionsV1alpha1AccessControlListRequest) Query(query string) ApiCountDefinitionsV1alpha1AccessControlListRequest {
	r.query = &query
	return r
}

// Set to \&quot;all\&quot; to fetch a count of all resources, including resources you do not have access to. Set to \&quot;accessible\&quot; to fetch a count resources you have access to, which is the default if not specified. Unknown values will return a bad request (400) status code.
func (r ApiCountDefinitionsV1alpha1AccessControlListRequest) Count(count string) ApiCountDefinitionsV1alpha1AccessControlListRequest {
	r.count = &count
	return r
}

func (r ApiCountDefinitionsV1alpha1AccessControlListRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountDefinitionsV1alpha1AccessControlListExecute(r)
}

/*
CountDefinitionsV1alpha1AccessControlList Retrieves a count of AccessControlList for version v1alpha1 from group definitions

Retrieves a count of AccessControlList for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCountDefinitionsV1alpha1AccessControlListRequest
*/
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1AccessControlList(ctx context.Context) ApiCountDefinitionsV1alpha1AccessControlListRequest {
	return ApiCountDefinitionsV1alpha1AccessControlListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1AccessControlListExecute(r ApiCountDefinitionsV1alpha1AccessControlListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CountDefinitionsV1alpha1AccessControlList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/accesscontrollists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountDefinitionsV1alpha1CommandLineInterfaceRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	xAxwayTenantId *string
	query *string
	count *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCountDefinitionsV1alpha1CommandLineInterfaceRequest) XAxwayTenantId(xAxwayTenantId string) ApiCountDefinitionsV1alpha1CommandLineInterfaceRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiCountDefinitionsV1alpha1CommandLineInterfaceRequest) Query(query string) ApiCountDefinitionsV1alpha1CommandLineInterfaceRequest {
	r.query = &query
	return r
}

// Set to \&quot;all\&quot; to fetch a count of all resources, including resources you do not have access to. Set to \&quot;accessible\&quot; to fetch a count resources you have access to, which is the default if not specified. Unknown values will return a bad request (400) status code.
func (r ApiCountDefinitionsV1alpha1CommandLineInterfaceRequest) Count(count string) ApiCountDefinitionsV1alpha1CommandLineInterfaceRequest {
	r.count = &count
	return r
}

func (r ApiCountDefinitionsV1alpha1CommandLineInterfaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountDefinitionsV1alpha1CommandLineInterfaceExecute(r)
}

/*
CountDefinitionsV1alpha1CommandLineInterface Retrieves a count of CommandLineInterface for version v1alpha1 from group definitions

Retrieves a count of CommandLineInterface for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCountDefinitionsV1alpha1CommandLineInterfaceRequest
*/
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1CommandLineInterface(ctx context.Context) ApiCountDefinitionsV1alpha1CommandLineInterfaceRequest {
	return ApiCountDefinitionsV1alpha1CommandLineInterfaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1CommandLineInterfaceExecute(r ApiCountDefinitionsV1alpha1CommandLineInterfaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CountDefinitionsV1alpha1CommandLineInterface")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/commandlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountDefinitionsV1alpha1ResourceDefinitionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	xAxwayTenantId *string
	query *string
	count *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCountDefinitionsV1alpha1ResourceDefinitionRequest) XAxwayTenantId(xAxwayTenantId string) ApiCountDefinitionsV1alpha1ResourceDefinitionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiCountDefinitionsV1alpha1ResourceDefinitionRequest) Query(query string) ApiCountDefinitionsV1alpha1ResourceDefinitionRequest {
	r.query = &query
	return r
}

// Set to \&quot;all\&quot; to fetch a count of all resources, including resources you do not have access to. Set to \&quot;accessible\&quot; to fetch a count resources you have access to, which is the default if not specified. Unknown values will return a bad request (400) status code.
func (r ApiCountDefinitionsV1alpha1ResourceDefinitionRequest) Count(count string) ApiCountDefinitionsV1alpha1ResourceDefinitionRequest {
	r.count = &count
	return r
}

func (r ApiCountDefinitionsV1alpha1ResourceDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountDefinitionsV1alpha1ResourceDefinitionExecute(r)
}

/*
CountDefinitionsV1alpha1ResourceDefinition Retrieves a count of ResourceDefinition for version v1alpha1 from group definitions

Retrieves a count of ResourceDefinition for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCountDefinitionsV1alpha1ResourceDefinitionRequest
*/
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceDefinition(ctx context.Context) ApiCountDefinitionsV1alpha1ResourceDefinitionRequest {
	return ApiCountDefinitionsV1alpha1ResourceDefinitionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceDefinitionExecute(r ApiCountDefinitionsV1alpha1ResourceDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CountDefinitionsV1alpha1ResourceDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/resources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountDefinitionsV1alpha1ResourceDefinitionVersionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	xAxwayTenantId *string
	query *string
	count *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCountDefinitionsV1alpha1ResourceDefinitionVersionRequest) XAxwayTenantId(xAxwayTenantId string) ApiCountDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiCountDefinitionsV1alpha1ResourceDefinitionVersionRequest) Query(query string) ApiCountDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	r.query = &query
	return r
}

// Set to \&quot;all\&quot; to fetch a count of all resources, including resources you do not have access to. Set to \&quot;accessible\&quot; to fetch a count resources you have access to, which is the default if not specified. Unknown values will return a bad request (400) status code.
func (r ApiCountDefinitionsV1alpha1ResourceDefinitionVersionRequest) Count(count string) ApiCountDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	r.count = &count
	return r
}

func (r ApiCountDefinitionsV1alpha1ResourceDefinitionVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountDefinitionsV1alpha1ResourceDefinitionVersionExecute(r)
}

/*
CountDefinitionsV1alpha1ResourceDefinitionVersion Retrieves a count of ResourceDefinitionVersion for version v1alpha1 from group definitions

Retrieves a count of ResourceDefinitionVersion for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCountDefinitionsV1alpha1ResourceDefinitionVersionRequest
*/
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceDefinitionVersion(ctx context.Context) ApiCountDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	return ApiCountDefinitionsV1alpha1ResourceDefinitionVersionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceDefinitionVersionExecute(r ApiCountDefinitionsV1alpha1ResourceDefinitionVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CountDefinitionsV1alpha1ResourceDefinitionVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/resourceversions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountDefinitionsV1alpha1ResourceGroupRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	xAxwayTenantId *string
	query *string
	count *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCountDefinitionsV1alpha1ResourceGroupRequest) XAxwayTenantId(xAxwayTenantId string) ApiCountDefinitionsV1alpha1ResourceGroupRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiCountDefinitionsV1alpha1ResourceGroupRequest) Query(query string) ApiCountDefinitionsV1alpha1ResourceGroupRequest {
	r.query = &query
	return r
}

// Set to \&quot;all\&quot; to fetch a count of all resources, including resources you do not have access to. Set to \&quot;accessible\&quot; to fetch a count resources you have access to, which is the default if not specified. Unknown values will return a bad request (400) status code.
func (r ApiCountDefinitionsV1alpha1ResourceGroupRequest) Count(count string) ApiCountDefinitionsV1alpha1ResourceGroupRequest {
	r.count = &count
	return r
}

func (r ApiCountDefinitionsV1alpha1ResourceGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountDefinitionsV1alpha1ResourceGroupExecute(r)
}

/*
CountDefinitionsV1alpha1ResourceGroup Retrieves a count of ResourceGroup for version v1alpha1 from group definitions

Retrieves a count of ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCountDefinitionsV1alpha1ResourceGroupRequest
*/
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceGroup(ctx context.Context) ApiCountDefinitionsV1alpha1ResourceGroupRequest {
	return ApiCountDefinitionsV1alpha1ResourceGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceGroupExecute(r ApiCountDefinitionsV1alpha1ResourceGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CountDefinitionsV1alpha1ResourceGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountDefinitionsV1alpha1ResourceGroupAccessControlListRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	xAxwayTenantId *string
	query *string
	count *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCountDefinitionsV1alpha1ResourceGroupAccessControlListRequest) XAxwayTenantId(xAxwayTenantId string) ApiCountDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiCountDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Query(query string) ApiCountDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.query = &query
	return r
}

// Set to \&quot;all\&quot; to fetch a count of all resources, including resources you do not have access to. Set to \&quot;accessible\&quot; to fetch a count resources you have access to, which is the default if not specified. Unknown values will return a bad request (400) status code.
func (r ApiCountDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Count(count string) ApiCountDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.count = &count
	return r
}

func (r ApiCountDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r)
}

/*
CountDefinitionsV1alpha1ResourceGroupAccessControlList Retrieves a count of AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves a count of AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @return ApiCountDefinitionsV1alpha1ResourceGroupAccessControlListRequest
*/
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceGroupAccessControlList(ctx context.Context, groupName string) ApiCountDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	return ApiCountDefinitionsV1alpha1ResourceGroupAccessControlListRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r ApiCountDefinitionsV1alpha1ResourceGroupAccessControlListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CountDefinitionsV1alpha1ResourceGroupAccessControlList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	xAxwayTenantId *string
	query *string
	count *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) XAxwayTenantId(xAxwayTenantId string) ApiCountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiCountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Query(query string) ApiCountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.query = &query
	return r
}

// Set to \&quot;all\&quot; to fetch a count of all resources, including resources you do not have access to. Set to \&quot;accessible\&quot; to fetch a count resources you have access to, which is the default if not specified. Unknown values will return a bad request (400) status code.
func (r ApiCountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Count(count string) ApiCountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.count = &count
	return r
}

func (r ApiCountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r)
}

/*
CountDefinitionsV1alpha1ResourceGroupCommandLineInterface Retrieves a count of CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves a count of CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @return ApiCountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest
*/
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceGroupCommandLineInterface(ctx context.Context, groupName string) ApiCountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	return ApiCountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r ApiCountDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CountDefinitionsV1alpha1ResourceGroupCommandLineInterface")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	xAxwayTenantId *string
	query *string
	count *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) XAxwayTenantId(xAxwayTenantId string) ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Query(query string) ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.query = &query
	return r
}

// Set to \&quot;all\&quot; to fetch a count of all resources, including resources you do not have access to. Set to \&quot;accessible\&quot; to fetch a count resources you have access to, which is the default if not specified. Unknown values will return a bad request (400) status code.
func (r ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Count(count string) ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.count = &count
	return r
}

func (r ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r)
}

/*
CountDefinitionsV1alpha1ResourceGroupResourceDefinition Retrieves a count of ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves a count of ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @return ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest
*/
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceGroupResourceDefinition(ctx context.Context, groupName string) ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	return ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CountDefinitionsV1alpha1ResourceGroupResourceDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	xAxwayTenantId *string
	query *string
	count *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) XAxwayTenantId(xAxwayTenantId string) ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Query(query string) ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.query = &query
	return r
}

// Set to \&quot;all\&quot; to fetch a count of all resources, including resources you do not have access to. Set to \&quot;accessible\&quot; to fetch a count resources you have access to, which is the default if not specified. Unknown values will return a bad request (400) status code.
func (r ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Count(count string) ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.count = &count
	return r
}

func (r ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.CountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r)
}

/*
CountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion Retrieves a count of ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves a count of ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @return ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest
*/
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion(ctx context.Context, groupName string) ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	return ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) CountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r ApiCountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CountDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateDefinitionsV1alpha1ResourceGroupRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	xAxwayTenantId *string
	fields *string
	definitionsV1alpha1ResourceGroup *DefinitionsV1alpha1ResourceGroup
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCreateDefinitionsV1alpha1ResourceGroupRequest) XAxwayTenantId(xAxwayTenantId string) ApiCreateDefinitionsV1alpha1ResourceGroupRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceGroup resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiCreateDefinitionsV1alpha1ResourceGroupRequest) Fields(fields string) ApiCreateDefinitionsV1alpha1ResourceGroupRequest {
	r.fields = &fields
	return r
}

func (r ApiCreateDefinitionsV1alpha1ResourceGroupRequest) DefinitionsV1alpha1ResourceGroup(definitionsV1alpha1ResourceGroup DefinitionsV1alpha1ResourceGroup) ApiCreateDefinitionsV1alpha1ResourceGroupRequest {
	r.definitionsV1alpha1ResourceGroup = &definitionsV1alpha1ResourceGroup
	return r
}

func (r ApiCreateDefinitionsV1alpha1ResourceGroupRequest) Execute() (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	return r.ApiService.CreateDefinitionsV1alpha1ResourceGroupExecute(r)
}

/*
CreateDefinitionsV1alpha1ResourceGroup Create ResourceGroup for version v1alpha1 from group definitions

Create ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDefinitionsV1alpha1ResourceGroupRequest
*/
func (a *DefinitionsAPIService) CreateDefinitionsV1alpha1ResourceGroup(ctx context.Context) ApiCreateDefinitionsV1alpha1ResourceGroupRequest {
	return ApiCreateDefinitionsV1alpha1ResourceGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceGroup
func (a *DefinitionsAPIService) CreateDefinitionsV1alpha1ResourceGroupExecute(r ApiCreateDefinitionsV1alpha1ResourceGroupRequest) (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CreateDefinitionsV1alpha1ResourceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDefinitionsV1alpha1ResourceGroupAccessControlListRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	xAxwayTenantId *string
	fields *string
	definitionsV1alpha1AccessControlList *DefinitionsV1alpha1AccessControlList
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCreateDefinitionsV1alpha1ResourceGroupAccessControlListRequest) XAxwayTenantId(xAxwayTenantId string) ApiCreateDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.AccessControlList resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiCreateDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Fields(fields string) ApiCreateDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.fields = &fields
	return r
}

func (r ApiCreateDefinitionsV1alpha1ResourceGroupAccessControlListRequest) DefinitionsV1alpha1AccessControlList(definitionsV1alpha1AccessControlList DefinitionsV1alpha1AccessControlList) ApiCreateDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.definitionsV1alpha1AccessControlList = &definitionsV1alpha1AccessControlList
	return r
}

func (r ApiCreateDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Execute() (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	return r.ApiService.CreateDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r)
}

/*
CreateDefinitionsV1alpha1ResourceGroupAccessControlList Create AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Create AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @return ApiCreateDefinitionsV1alpha1ResourceGroupAccessControlListRequest
*/
func (a *DefinitionsAPIService) CreateDefinitionsV1alpha1ResourceGroupAccessControlList(ctx context.Context, groupName string) ApiCreateDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	return ApiCreateDefinitionsV1alpha1ResourceGroupAccessControlListRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1AccessControlList
func (a *DefinitionsAPIService) CreateDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r ApiCreateDefinitionsV1alpha1ResourceGroupAccessControlListRequest) (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1AccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CreateDefinitionsV1alpha1ResourceGroupAccessControlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1AccessControlList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	xAxwayTenantId *string
	fields *string
	definitionsV1alpha1CommandLineInterface *DefinitionsV1alpha1CommandLineInterface
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) XAxwayTenantId(xAxwayTenantId string) ApiCreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.CommandLineInterface resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiCreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Fields(fields string) ApiCreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.fields = &fields
	return r
}

func (r ApiCreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) DefinitionsV1alpha1CommandLineInterface(definitionsV1alpha1CommandLineInterface DefinitionsV1alpha1CommandLineInterface) ApiCreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.definitionsV1alpha1CommandLineInterface = &definitionsV1alpha1CommandLineInterface
	return r
}

func (r ApiCreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Execute() (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	return r.ApiService.CreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r)
}

/*
CreateDefinitionsV1alpha1ResourceGroupCommandLineInterface Create CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Create CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @return ApiCreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest
*/
func (a *DefinitionsAPIService) CreateDefinitionsV1alpha1ResourceGroupCommandLineInterface(ctx context.Context, groupName string) ApiCreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	return ApiCreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1CommandLineInterface
func (a *DefinitionsAPIService) CreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r ApiCreateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1CommandLineInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CreateDefinitionsV1alpha1ResourceGroupCommandLineInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1CommandLineInterface
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	xAxwayTenantId *string
	fields *string
	definitionsV1alpha1ResourceDefinition *DefinitionsV1alpha1ResourceDefinition
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) XAxwayTenantId(xAxwayTenantId string) ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinition resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Fields(fields string) ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.fields = &fields
	return r
}

func (r ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) DefinitionsV1alpha1ResourceDefinition(definitionsV1alpha1ResourceDefinition DefinitionsV1alpha1ResourceDefinition) ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.definitionsV1alpha1ResourceDefinition = &definitionsV1alpha1ResourceDefinition
	return r
}

func (r ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Execute() (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	return r.ApiService.CreateDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r)
}

/*
CreateDefinitionsV1alpha1ResourceGroupResourceDefinition Create ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Create ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @return ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest
*/
func (a *DefinitionsAPIService) CreateDefinitionsV1alpha1ResourceGroupResourceDefinition(ctx context.Context, groupName string) ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	return ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinition
func (a *DefinitionsAPIService) CreateDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CreateDefinitionsV1alpha1ResourceGroupResourceDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	xAxwayTenantId *string
	fields *string
	definitionsV1alpha1ResourceDefinitionVersion *DefinitionsV1alpha1ResourceDefinitionVersion
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) XAxwayTenantId(xAxwayTenantId string) ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinitionVersion resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Fields(fields string) ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.fields = &fields
	return r
}

func (r ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) DefinitionsV1alpha1ResourceDefinitionVersion(definitionsV1alpha1ResourceDefinitionVersion DefinitionsV1alpha1ResourceDefinitionVersion) ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.definitionsV1alpha1ResourceDefinitionVersion = &definitionsV1alpha1ResourceDefinitionVersion
	return r
}

func (r ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Execute() (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	return r.ApiService.CreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r)
}

/*
CreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion Create ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Create ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @return ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest
*/
func (a *DefinitionsAPIService) CreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion(ctx context.Context, groupName string) ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	return ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinitionVersion
func (a *DefinitionsAPIService) CreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r ApiCreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinitionVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.CreateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceDefinitionVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDefinitionsV1alpha1AccessControlListRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	xAxwayTenantId *string
	page *int32
	pageSize *int32
	sort *string
	embed *string
	expand *string
	resourceLanguageCode *string
	query *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiListDefinitionsV1alpha1AccessControlListRequest) XAxwayTenantId(xAxwayTenantId string) ApiListDefinitionsV1alpha1AccessControlListRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// The offset starting page number in the result set to start returning results from, starts at 1.
func (r ApiListDefinitionsV1alpha1AccessControlListRequest) Page(page int32) ApiListDefinitionsV1alpha1AccessControlListRequest {
	r.page = &page
	return r
}

// The number of entities allowed in a page.
func (r ApiListDefinitionsV1alpha1AccessControlListRequest) PageSize(pageSize int32) ApiListDefinitionsV1alpha1AccessControlListRequest {
	r.pageSize = &pageSize
	return r
}

// The field to sort result sets by, in ASC or DESC order. Allowed fields for sorting:         name         title         metadata.audit.createTimestamp         metadata.audit.modifyTimestamp
func (r ApiListDefinitionsV1alpha1AccessControlListRequest) Sort(sort string) ApiListDefinitionsV1alpha1AccessControlListRequest {
	r.sort = &sort
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiListDefinitionsV1alpha1AccessControlListRequest) Embed(embed string) ApiListDefinitionsV1alpha1AccessControlListRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiListDefinitionsV1alpha1AccessControlListRequest) Expand(expand string) ApiListDefinitionsV1alpha1AccessControlListRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiListDefinitionsV1alpha1AccessControlListRequest) ResourceLanguageCode(resourceLanguageCode string) ApiListDefinitionsV1alpha1AccessControlListRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiListDefinitionsV1alpha1AccessControlListRequest) Query(query string) ApiListDefinitionsV1alpha1AccessControlListRequest {
	r.query = &query
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.AccessControlList resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiListDefinitionsV1alpha1AccessControlListRequest) Fields(fields string) ApiListDefinitionsV1alpha1AccessControlListRequest {
	r.fields = &fields
	return r
}

func (r ApiListDefinitionsV1alpha1AccessControlListRequest) Execute() ([]DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	return r.ApiService.ListDefinitionsV1alpha1AccessControlListExecute(r)
}

/*
ListDefinitionsV1alpha1AccessControlList Retrieves AccessControlList for version v1alpha1 from group definitions

Retrieves AccessControlList for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDefinitionsV1alpha1AccessControlListRequest
*/
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1AccessControlList(ctx context.Context) ApiListDefinitionsV1alpha1AccessControlListRequest {
	return ApiListDefinitionsV1alpha1AccessControlListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DefinitionsV1alpha1AccessControlList
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1AccessControlListExecute(r ApiListDefinitionsV1alpha1AccessControlListRequest) ([]DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DefinitionsV1alpha1AccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ListDefinitionsV1alpha1AccessControlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/accesscontrollists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDefinitionsV1alpha1CommandLineInterfaceRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	xAxwayTenantId *string
	page *int32
	pageSize *int32
	sort *string
	embed *string
	expand *string
	resourceLanguageCode *string
	query *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiListDefinitionsV1alpha1CommandLineInterfaceRequest) XAxwayTenantId(xAxwayTenantId string) ApiListDefinitionsV1alpha1CommandLineInterfaceRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// The offset starting page number in the result set to start returning results from, starts at 1.
func (r ApiListDefinitionsV1alpha1CommandLineInterfaceRequest) Page(page int32) ApiListDefinitionsV1alpha1CommandLineInterfaceRequest {
	r.page = &page
	return r
}

// The number of entities allowed in a page.
func (r ApiListDefinitionsV1alpha1CommandLineInterfaceRequest) PageSize(pageSize int32) ApiListDefinitionsV1alpha1CommandLineInterfaceRequest {
	r.pageSize = &pageSize
	return r
}

// The field to sort result sets by, in ASC or DESC order. Allowed fields for sorting:         name         title         metadata.audit.createTimestamp         metadata.audit.modifyTimestamp
func (r ApiListDefinitionsV1alpha1CommandLineInterfaceRequest) Sort(sort string) ApiListDefinitionsV1alpha1CommandLineInterfaceRequest {
	r.sort = &sort
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiListDefinitionsV1alpha1CommandLineInterfaceRequest) Embed(embed string) ApiListDefinitionsV1alpha1CommandLineInterfaceRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiListDefinitionsV1alpha1CommandLineInterfaceRequest) Expand(expand string) ApiListDefinitionsV1alpha1CommandLineInterfaceRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiListDefinitionsV1alpha1CommandLineInterfaceRequest) ResourceLanguageCode(resourceLanguageCode string) ApiListDefinitionsV1alpha1CommandLineInterfaceRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiListDefinitionsV1alpha1CommandLineInterfaceRequest) Query(query string) ApiListDefinitionsV1alpha1CommandLineInterfaceRequest {
	r.query = &query
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.CommandLineInterface resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiListDefinitionsV1alpha1CommandLineInterfaceRequest) Fields(fields string) ApiListDefinitionsV1alpha1CommandLineInterfaceRequest {
	r.fields = &fields
	return r
}

func (r ApiListDefinitionsV1alpha1CommandLineInterfaceRequest) Execute() ([]DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	return r.ApiService.ListDefinitionsV1alpha1CommandLineInterfaceExecute(r)
}

/*
ListDefinitionsV1alpha1CommandLineInterface Retrieves CommandLineInterface for version v1alpha1 from group definitions

Retrieves CommandLineInterface for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDefinitionsV1alpha1CommandLineInterfaceRequest
*/
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1CommandLineInterface(ctx context.Context) ApiListDefinitionsV1alpha1CommandLineInterfaceRequest {
	return ApiListDefinitionsV1alpha1CommandLineInterfaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DefinitionsV1alpha1CommandLineInterface
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1CommandLineInterfaceExecute(r ApiListDefinitionsV1alpha1CommandLineInterfaceRequest) ([]DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DefinitionsV1alpha1CommandLineInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ListDefinitionsV1alpha1CommandLineInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/commandlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDefinitionsV1alpha1ResourceDefinitionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	xAxwayTenantId *string
	page *int32
	pageSize *int32
	sort *string
	embed *string
	expand *string
	resourceLanguageCode *string
	query *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiListDefinitionsV1alpha1ResourceDefinitionRequest) XAxwayTenantId(xAxwayTenantId string) ApiListDefinitionsV1alpha1ResourceDefinitionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// The offset starting page number in the result set to start returning results from, starts at 1.
func (r ApiListDefinitionsV1alpha1ResourceDefinitionRequest) Page(page int32) ApiListDefinitionsV1alpha1ResourceDefinitionRequest {
	r.page = &page
	return r
}

// The number of entities allowed in a page.
func (r ApiListDefinitionsV1alpha1ResourceDefinitionRequest) PageSize(pageSize int32) ApiListDefinitionsV1alpha1ResourceDefinitionRequest {
	r.pageSize = &pageSize
	return r
}

// The field to sort result sets by, in ASC or DESC order. Allowed fields for sorting:         name         title         metadata.audit.createTimestamp         metadata.audit.modifyTimestamp
func (r ApiListDefinitionsV1alpha1ResourceDefinitionRequest) Sort(sort string) ApiListDefinitionsV1alpha1ResourceDefinitionRequest {
	r.sort = &sort
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiListDefinitionsV1alpha1ResourceDefinitionRequest) Embed(embed string) ApiListDefinitionsV1alpha1ResourceDefinitionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiListDefinitionsV1alpha1ResourceDefinitionRequest) Expand(expand string) ApiListDefinitionsV1alpha1ResourceDefinitionRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiListDefinitionsV1alpha1ResourceDefinitionRequest) ResourceLanguageCode(resourceLanguageCode string) ApiListDefinitionsV1alpha1ResourceDefinitionRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiListDefinitionsV1alpha1ResourceDefinitionRequest) Query(query string) ApiListDefinitionsV1alpha1ResourceDefinitionRequest {
	r.query = &query
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinition resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiListDefinitionsV1alpha1ResourceDefinitionRequest) Fields(fields string) ApiListDefinitionsV1alpha1ResourceDefinitionRequest {
	r.fields = &fields
	return r
}

func (r ApiListDefinitionsV1alpha1ResourceDefinitionRequest) Execute() ([]DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	return r.ApiService.ListDefinitionsV1alpha1ResourceDefinitionExecute(r)
}

/*
ListDefinitionsV1alpha1ResourceDefinition Retrieves ResourceDefinition for version v1alpha1 from group definitions

Retrieves ResourceDefinition for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDefinitionsV1alpha1ResourceDefinitionRequest
*/
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceDefinition(ctx context.Context) ApiListDefinitionsV1alpha1ResourceDefinitionRequest {
	return ApiListDefinitionsV1alpha1ResourceDefinitionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DefinitionsV1alpha1ResourceDefinition
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceDefinitionExecute(r ApiListDefinitionsV1alpha1ResourceDefinitionRequest) ([]DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DefinitionsV1alpha1ResourceDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ListDefinitionsV1alpha1ResourceDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/resources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	xAxwayTenantId *string
	page *int32
	pageSize *int32
	sort *string
	embed *string
	expand *string
	resourceLanguageCode *string
	query *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest) XAxwayTenantId(xAxwayTenantId string) ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// The offset starting page number in the result set to start returning results from, starts at 1.
func (r ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest) Page(page int32) ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	r.page = &page
	return r
}

// The number of entities allowed in a page.
func (r ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest) PageSize(pageSize int32) ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	r.pageSize = &pageSize
	return r
}

// The field to sort result sets by, in ASC or DESC order. Allowed fields for sorting:         name         title         metadata.audit.createTimestamp         metadata.audit.modifyTimestamp
func (r ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest) Sort(sort string) ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	r.sort = &sort
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest) Embed(embed string) ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest) Expand(expand string) ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest) ResourceLanguageCode(resourceLanguageCode string) ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest) Query(query string) ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	r.query = &query
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinitionVersion resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest) Fields(fields string) ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	r.fields = &fields
	return r
}

func (r ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest) Execute() ([]DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	return r.ApiService.ListDefinitionsV1alpha1ResourceDefinitionVersionExecute(r)
}

/*
ListDefinitionsV1alpha1ResourceDefinitionVersion Retrieves ResourceDefinitionVersion for version v1alpha1 from group definitions

Retrieves ResourceDefinitionVersion for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest
*/
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceDefinitionVersion(ctx context.Context) ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest {
	return ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DefinitionsV1alpha1ResourceDefinitionVersion
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceDefinitionVersionExecute(r ApiListDefinitionsV1alpha1ResourceDefinitionVersionRequest) ([]DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DefinitionsV1alpha1ResourceDefinitionVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ListDefinitionsV1alpha1ResourceDefinitionVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/resourceversions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDefinitionsV1alpha1ResourceGroupRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	xAxwayTenantId *string
	page *int32
	pageSize *int32
	sort *string
	embed *string
	expand *string
	resourceLanguageCode *string
	query *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiListDefinitionsV1alpha1ResourceGroupRequest) XAxwayTenantId(xAxwayTenantId string) ApiListDefinitionsV1alpha1ResourceGroupRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// The offset starting page number in the result set to start returning results from, starts at 1.
func (r ApiListDefinitionsV1alpha1ResourceGroupRequest) Page(page int32) ApiListDefinitionsV1alpha1ResourceGroupRequest {
	r.page = &page
	return r
}

// The number of entities allowed in a page.
func (r ApiListDefinitionsV1alpha1ResourceGroupRequest) PageSize(pageSize int32) ApiListDefinitionsV1alpha1ResourceGroupRequest {
	r.pageSize = &pageSize
	return r
}

// The field to sort result sets by, in ASC or DESC order. Allowed fields for sorting:         name         title         metadata.audit.createTimestamp         metadata.audit.modifyTimestamp
func (r ApiListDefinitionsV1alpha1ResourceGroupRequest) Sort(sort string) ApiListDefinitionsV1alpha1ResourceGroupRequest {
	r.sort = &sort
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiListDefinitionsV1alpha1ResourceGroupRequest) Embed(embed string) ApiListDefinitionsV1alpha1ResourceGroupRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiListDefinitionsV1alpha1ResourceGroupRequest) Expand(expand string) ApiListDefinitionsV1alpha1ResourceGroupRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiListDefinitionsV1alpha1ResourceGroupRequest) ResourceLanguageCode(resourceLanguageCode string) ApiListDefinitionsV1alpha1ResourceGroupRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiListDefinitionsV1alpha1ResourceGroupRequest) Query(query string) ApiListDefinitionsV1alpha1ResourceGroupRequest {
	r.query = &query
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceGroup resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiListDefinitionsV1alpha1ResourceGroupRequest) Fields(fields string) ApiListDefinitionsV1alpha1ResourceGroupRequest {
	r.fields = &fields
	return r
}

func (r ApiListDefinitionsV1alpha1ResourceGroupRequest) Execute() ([]DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	return r.ApiService.ListDefinitionsV1alpha1ResourceGroupExecute(r)
}

/*
ListDefinitionsV1alpha1ResourceGroup Retrieves ResourceGroup for version v1alpha1 from group definitions

Retrieves ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDefinitionsV1alpha1ResourceGroupRequest
*/
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceGroup(ctx context.Context) ApiListDefinitionsV1alpha1ResourceGroupRequest {
	return ApiListDefinitionsV1alpha1ResourceGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DefinitionsV1alpha1ResourceGroup
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceGroupExecute(r ApiListDefinitionsV1alpha1ResourceGroupRequest) ([]DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DefinitionsV1alpha1ResourceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ListDefinitionsV1alpha1ResourceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	xAxwayTenantId *string
	page *int32
	pageSize *int32
	sort *string
	embed *string
	expand *string
	resourceLanguageCode *string
	query *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest) XAxwayTenantId(xAxwayTenantId string) ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// The offset starting page number in the result set to start returning results from, starts at 1.
func (r ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Page(page int32) ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.page = &page
	return r
}

// The number of entities allowed in a page.
func (r ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest) PageSize(pageSize int32) ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.pageSize = &pageSize
	return r
}

// The field to sort result sets by, in ASC or DESC order. Allowed fields for sorting:         name         title         metadata.audit.createTimestamp         metadata.audit.modifyTimestamp
func (r ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Sort(sort string) ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.sort = &sort
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Embed(embed string) ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Expand(expand string) ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest) ResourceLanguageCode(resourceLanguageCode string) ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Query(query string) ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.query = &query
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.AccessControlList resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Fields(fields string) ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.fields = &fields
	return r
}

func (r ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Execute() ([]DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	return r.ApiService.ListDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r)
}

/*
ListDefinitionsV1alpha1ResourceGroupAccessControlList Retrieves AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @return ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest
*/
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceGroupAccessControlList(ctx context.Context, groupName string) ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	return ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return []DefinitionsV1alpha1AccessControlList
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r ApiListDefinitionsV1alpha1ResourceGroupAccessControlListRequest) ([]DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DefinitionsV1alpha1AccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ListDefinitionsV1alpha1ResourceGroupAccessControlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	xAxwayTenantId *string
	page *int32
	pageSize *int32
	sort *string
	embed *string
	expand *string
	resourceLanguageCode *string
	query *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) XAxwayTenantId(xAxwayTenantId string) ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// The offset starting page number in the result set to start returning results from, starts at 1.
func (r ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Page(page int32) ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.page = &page
	return r
}

// The number of entities allowed in a page.
func (r ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) PageSize(pageSize int32) ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.pageSize = &pageSize
	return r
}

// The field to sort result sets by, in ASC or DESC order. Allowed fields for sorting:         name         title         metadata.audit.createTimestamp         metadata.audit.modifyTimestamp
func (r ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Sort(sort string) ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.sort = &sort
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Embed(embed string) ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Expand(expand string) ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) ResourceLanguageCode(resourceLanguageCode string) ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Query(query string) ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.query = &query
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.CommandLineInterface resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Fields(fields string) ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.fields = &fields
	return r
}

func (r ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Execute() ([]DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	return r.ApiService.ListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r)
}

/*
ListDefinitionsV1alpha1ResourceGroupCommandLineInterface Retrieves CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @return ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest
*/
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceGroupCommandLineInterface(ctx context.Context, groupName string) ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	return ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return []DefinitionsV1alpha1CommandLineInterface
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r ApiListDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) ([]DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DefinitionsV1alpha1CommandLineInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ListDefinitionsV1alpha1ResourceGroupCommandLineInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	xAxwayTenantId *string
	page *int32
	pageSize *int32
	sort *string
	embed *string
	expand *string
	resourceLanguageCode *string
	query *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) XAxwayTenantId(xAxwayTenantId string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// The offset starting page number in the result set to start returning results from, starts at 1.
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Page(page int32) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.page = &page
	return r
}

// The number of entities allowed in a page.
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) PageSize(pageSize int32) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.pageSize = &pageSize
	return r
}

// The field to sort result sets by, in ASC or DESC order. Allowed fields for sorting:         name         title         metadata.audit.createTimestamp         metadata.audit.modifyTimestamp
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Sort(sort string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.sort = &sort
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Embed(embed string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Expand(expand string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) ResourceLanguageCode(resourceLanguageCode string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Query(query string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.query = &query
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinition resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Fields(fields string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.fields = &fields
	return r
}

func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Execute() ([]DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	return r.ApiService.ListDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r)
}

/*
ListDefinitionsV1alpha1ResourceGroupResourceDefinition Retrieves ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @return ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest
*/
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceGroupResourceDefinition(ctx context.Context, groupName string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	return ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return []DefinitionsV1alpha1ResourceDefinition
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) ([]DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DefinitionsV1alpha1ResourceDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ListDefinitionsV1alpha1ResourceGroupResourceDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	xAxwayTenantId *string
	page *int32
	pageSize *int32
	sort *string
	embed *string
	expand *string
	resourceLanguageCode *string
	query *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) XAxwayTenantId(xAxwayTenantId string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// The offset starting page number in the result set to start returning results from, starts at 1.
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Page(page int32) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.page = &page
	return r
}

// The number of entities allowed in a page.
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) PageSize(pageSize int32) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.pageSize = &pageSize
	return r
}

// The field to sort result sets by, in ASC or DESC order. Allowed fields for sorting:         name         title         metadata.audit.createTimestamp         metadata.audit.modifyTimestamp
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Sort(sort string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.sort = &sort
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Embed(embed string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Expand(expand string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) ResourceLanguageCode(resourceLanguageCode string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for filtering entity. Expressed in FIQL/RSQL language. Supported filters on resources: * name * title * tags * attributes * metadata.id * metadata.state * metadata.references.id * metadata.references.kind * metadata.references.name * metadata.deletedReferences.id * metadata.deletedReferences.kind * metadata.deletedReferences.name * metadata.resourceVersion * metadata.audit.createTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ * metadata.audit.modifyTimestamp - Date filter must be provided as epoch time or yyyy-MM-dd\\&#39;T\\&#39;HH:mm:ss.SSSZZZZ  Documentation link to help with multiple values for query: https://github.com/jirutka/rsql-parser
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Query(query string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.query = &query
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinitionVersion resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Fields(fields string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.fields = &fields
	return r
}

func (r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Execute() ([]DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	return r.ApiService.ListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r)
}

/*
ListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion Retrieves ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @return ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest
*/
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion(ctx context.Context, groupName string) ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	return ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return []DefinitionsV1alpha1ResourceDefinitionVersion
func (a *DefinitionsAPIService) ListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r ApiListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) ([]DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DefinitionsV1alpha1ResourceDefinitionVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ListDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDefinitionsV1alpha1ResourceGroupRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	apiV1JsonPatch *[]ApiV1JsonPatch
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiPatchDefinitionsV1alpha1ResourceGroupRequest) XAxwayTenantId(xAxwayTenantId string) ApiPatchDefinitionsV1alpha1ResourceGroupRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiPatchDefinitionsV1alpha1ResourceGroupRequest) Embed(embed string) ApiPatchDefinitionsV1alpha1ResourceGroupRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiPatchDefinitionsV1alpha1ResourceGroupRequest) Expand(expand string) ApiPatchDefinitionsV1alpha1ResourceGroupRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceGroup resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiPatchDefinitionsV1alpha1ResourceGroupRequest) Fields(fields string) ApiPatchDefinitionsV1alpha1ResourceGroupRequest {
	r.fields = &fields
	return r
}

func (r ApiPatchDefinitionsV1alpha1ResourceGroupRequest) ApiV1JsonPatch(apiV1JsonPatch []ApiV1JsonPatch) ApiPatchDefinitionsV1alpha1ResourceGroupRequest {
	r.apiV1JsonPatch = &apiV1JsonPatch
	return r
}

func (r ApiPatchDefinitionsV1alpha1ResourceGroupRequest) Execute() (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	return r.ApiService.PatchDefinitionsV1alpha1ResourceGroupExecute(r)
}

/*
PatchDefinitionsV1alpha1ResourceGroup Patch ResourceGroup for version v1alpha1 from group definitions

Patch ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the ResourceGroup
 @return ApiPatchDefinitionsV1alpha1ResourceGroupRequest
*/
func (a *DefinitionsAPIService) PatchDefinitionsV1alpha1ResourceGroup(ctx context.Context, name string) ApiPatchDefinitionsV1alpha1ResourceGroupRequest {
	return ApiPatchDefinitionsV1alpha1ResourceGroupRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceGroup
func (a *DefinitionsAPIService) PatchDefinitionsV1alpha1ResourceGroupExecute(r ApiPatchDefinitionsV1alpha1ResourceGroupRequest) (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.PatchDefinitionsV1alpha1ResourceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.apiV1JsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	apiV1JsonPatch *[]ApiV1JsonPatch
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest) XAxwayTenantId(xAxwayTenantId string) ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Embed(embed string) ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Expand(expand string) ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.AccessControlList resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Fields(fields string) ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.fields = &fields
	return r
}

func (r ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest) ApiV1JsonPatch(apiV1JsonPatch []ApiV1JsonPatch) ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.apiV1JsonPatch = &apiV1JsonPatch
	return r
}

func (r ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Execute() (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	return r.ApiService.PatchDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r)
}

/*
PatchDefinitionsV1alpha1ResourceGroupAccessControlList Patch AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Patch AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the AccessControlList
 @return ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest
*/
func (a *DefinitionsAPIService) PatchDefinitionsV1alpha1ResourceGroupAccessControlList(ctx context.Context, groupName string, name string) ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	return ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1AccessControlList
func (a *DefinitionsAPIService) PatchDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r ApiPatchDefinitionsV1alpha1ResourceGroupAccessControlListRequest) (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1AccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.PatchDefinitionsV1alpha1ResourceGroupAccessControlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.apiV1JsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	apiV1JsonPatch *[]ApiV1JsonPatch
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) XAxwayTenantId(xAxwayTenantId string) ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Embed(embed string) ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Expand(expand string) ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.CommandLineInterface resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Fields(fields string) ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.fields = &fields
	return r
}

func (r ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) ApiV1JsonPatch(apiV1JsonPatch []ApiV1JsonPatch) ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.apiV1JsonPatch = &apiV1JsonPatch
	return r
}

func (r ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Execute() (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	return r.ApiService.PatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r)
}

/*
PatchDefinitionsV1alpha1ResourceGroupCommandLineInterface Patch CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Patch CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the CommandLineInterface
 @return ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest
*/
func (a *DefinitionsAPIService) PatchDefinitionsV1alpha1ResourceGroupCommandLineInterface(ctx context.Context, groupName string, name string) ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	return ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1CommandLineInterface
func (a *DefinitionsAPIService) PatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r ApiPatchDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1CommandLineInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.PatchDefinitionsV1alpha1ResourceGroupCommandLineInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.apiV1JsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	apiV1JsonPatch *[]ApiV1JsonPatch
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) XAxwayTenantId(xAxwayTenantId string) ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Embed(embed string) ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Expand(expand string) ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinition resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Fields(fields string) ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.fields = &fields
	return r
}

func (r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) ApiV1JsonPatch(apiV1JsonPatch []ApiV1JsonPatch) ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.apiV1JsonPatch = &apiV1JsonPatch
	return r
}

func (r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Execute() (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	return r.ApiService.PatchDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r)
}

/*
PatchDefinitionsV1alpha1ResourceGroupResourceDefinition Patch ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Patch ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the ResourceDefinition
 @return ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest
*/
func (a *DefinitionsAPIService) PatchDefinitionsV1alpha1ResourceGroupResourceDefinition(ctx context.Context, groupName string, name string) ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	return ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinition
func (a *DefinitionsAPIService) PatchDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.PatchDefinitionsV1alpha1ResourceGroupResourceDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.apiV1JsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	apiV1JsonPatch *[]ApiV1JsonPatch
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) XAxwayTenantId(xAxwayTenantId string) ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Embed(embed string) ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Expand(expand string) ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinitionVersion resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Fields(fields string) ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.fields = &fields
	return r
}

func (r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) ApiV1JsonPatch(apiV1JsonPatch []ApiV1JsonPatch) ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.apiV1JsonPatch = &apiV1JsonPatch
	return r
}

func (r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Execute() (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	return r.ApiService.PatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r)
}

/*
PatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion Patch ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Patch ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the ResourceDefinitionVersion
 @return ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest
*/
func (a *DefinitionsAPIService) PatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion(ctx context.Context, groupName string, name string) ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	return ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinitionVersion
func (a *DefinitionsAPIService) PatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r ApiPatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinitionVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.PatchDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.apiV1JsonPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceGroup resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupRequest) Execute() (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroup Retrieves ResourceGroup for version v1alpha1 from group definitions

Retrieves ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the ResourceGroup
 @return ApiReadDefinitionsV1alpha1ResourceGroupRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroup(ctx context.Context, name string) ApiReadDefinitionsV1alpha1ResourceGroupRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceGroup
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupExecute(r ApiReadDefinitionsV1alpha1ResourceGroupRequest) (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.AccessControlList resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Execute() (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupAccessControlList Retrieves AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the AccessControlList
 @return ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupAccessControlList(ctx context.Context, groupName string, name string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1AccessControlList
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListRequest) (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1AccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupAccessControlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	extension string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.AccessControlList resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) Execute() (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupAccessControlListExtension Retrieves Extension resource data of AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves Extension resource data of AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param extension Name of the extension
 @param name The name of the AccessControlList
 @return ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupAccessControlListExtension(ctx context.Context, groupName string, extension string, name string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		extension: extension,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1AccessControlList
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionExecute(r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1AccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupAccessControlListExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists/{name}/{extension}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension"+"}", url.PathEscape(parameterValueToString(r.extension, "extension")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.AccessControlList resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) Execute() (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguages Retrieves Languages data for AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves Languages data for AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the AccessControlList
 @return ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguages(ctx context.Context, groupName string, name string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1AccessControlList
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesExecute(r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1AccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists/{name}/languages"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	code string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.AccessControlList resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) Execute() (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCode Retrieves Languages data for AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves Languages data for AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param code Language code.
 @param name The name of the AccessControlList
 @return ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCode(ctx context.Context, groupName string, code string, name string) ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		code: code,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1AccessControlList
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeExecute(r ApiReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1AccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists/{name}/languages-{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.CommandLineInterface resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Execute() (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupCommandLineInterface Retrieves CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the CommandLineInterface
 @return ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupCommandLineInterface(ctx context.Context, groupName string, name string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1CommandLineInterface
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1CommandLineInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupCommandLineInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	extension string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.CommandLineInterface resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) Execute() (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtension Retrieves Extension resource data of CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves Extension resource data of CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param extension Name of the extension
 @param name The name of the CommandLineInterface
 @return ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtension(ctx context.Context, groupName string, extension string, name string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		extension: extension,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1CommandLineInterface
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionExecute(r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1CommandLineInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines/{name}/{extension}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension"+"}", url.PathEscape(parameterValueToString(r.extension, "extension")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.CommandLineInterface resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) Execute() (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguages Retrieves Languages data for CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves Languages data for CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the CommandLineInterface
 @return ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguages(ctx context.Context, groupName string, name string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1CommandLineInterface
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesExecute(r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1CommandLineInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines/{name}/languages"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	code string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.CommandLineInterface resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) Execute() (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCode Retrieves Languages data for CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves Languages data for CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param code Language code.
 @param name The name of the CommandLineInterface
 @return ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCode(ctx context.Context, groupName string, code string, name string) ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		code: code,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1CommandLineInterface
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeExecute(r ApiReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1CommandLineInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines/{name}/languages-{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	extension string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceGroup resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest) Execute() (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupExtensionExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupExtension Retrieves Extension resource data of ResourceGroup for version v1alpha1 from group definitions

Retrieves Extension resource data of ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param extension Name of the extension
 @param name The name of the ResourceGroup
 @return ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupExtension(ctx context.Context, extension string, name string) ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest{
		ApiService: a,
		ctx: ctx,
		extension: extension,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceGroup
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupExtensionExecute(r ApiReadDefinitionsV1alpha1ResourceGroupExtensionRequest) (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{name}/{extension}"
	localVarPath = strings.Replace(localVarPath, "{"+"extension"+"}", url.PathEscape(parameterValueToString(r.extension, "extension")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceGroup resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest) Execute() (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupLanguagesExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupLanguages Retrieves Languages data for ResourceGroup for version v1alpha1 from group definitions

Retrieves Languages data for ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the ResourceGroup
 @return ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupLanguages(ctx context.Context, name string) ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceGroup
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupLanguagesExecute(r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesRequest) (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{name}/languages"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	code string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceGroup resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) Execute() (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupLanguagesCodeExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupLanguagesCode Retrieves Languages data for ResourceGroup for version v1alpha1 from group definitions

Retrieves Languages data for ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code Language code.
 @param name The name of the ResourceGroup
 @return ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupLanguagesCode(ctx context.Context, code string, name string) ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceGroup
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupLanguagesCodeExecute(r ApiReadDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupLanguagesCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{name}/languages-{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinition resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Execute() (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupResourceDefinition Retrieves ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the ResourceDefinition
 @return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinition(ctx context.Context, groupName string, name string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinition
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	extension string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinition resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) Execute() (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtension Retrieves Extension resource data of ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves Extension resource data of ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param extension Name of the extension
 @param name The name of the ResourceDefinition
 @return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtension(ctx context.Context, groupName string, extension string, name string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		extension: extension,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinition
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionExecute(r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources/{name}/{extension}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension"+"}", url.PathEscape(parameterValueToString(r.extension, "extension")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinition resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) Execute() (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguages Retrieves Languages data for ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves Languages data for ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the ResourceDefinition
 @return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguages(ctx context.Context, groupName string, name string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinition
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesExecute(r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources/{name}/languages"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	code string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinition resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) Execute() (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCode Retrieves Languages data for ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves Languages data for ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param code Language code.
 @param name The name of the ResourceDefinition
 @return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCode(ctx context.Context, groupName string, code string, name string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		code: code,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinition
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeExecute(r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources/{name}/languages-{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinitionVersion resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Execute() (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion Retrieves ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the ResourceDefinitionVersion
 @return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion(ctx context.Context, groupName string, name string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinitionVersion
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinitionVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	extension string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinitionVersion resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) Execute() (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtension Retrieves Extension resource data of ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves Extension resource data of ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param extension Name of the extension
 @param name The name of the ResourceDefinitionVersion
 @return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtension(ctx context.Context, groupName string, extension string, name string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		extension: extension,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinitionVersion
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionExecute(r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinitionVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions/{name}/{extension}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension"+"}", url.PathEscape(parameterValueToString(r.extension, "extension")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinitionVersion resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) Execute() (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguages Retrieves Languages data for ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves Languages data for ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the ResourceDefinitionVersion
 @return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguages(ctx context.Context, groupName string, name string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinitionVersion
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesExecute(r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinitionVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions/{name}/languages"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	code string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	resourceLanguageCode *string
	fields *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) XAxwayTenantId(xAxwayTenantId string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) Embed(embed string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) Expand(expand string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest {
	r.expand = &expand
	return r
}

// Defines in which language(\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) the resource is retrieved. If the requested language does not exist or a property in that language was not internationalized, the resource default language value will be returned. 
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) ResourceLanguageCode(resourceLanguageCode string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest {
	r.resourceLanguageCode = &resourceLanguageCode
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinitionVersion resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) Fields(fields string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest {
	r.fields = &fields
	return r
}

func (r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) Execute() (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	return r.ApiService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeExecute(r)
}

/*
ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCode Retrieves Languages data for ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Retrieves Languages data for ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param code Language code.
 @param name The name of the ResourceDefinitionVersion
 @return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest
*/
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCode(ctx context.Context, groupName string, code string, name string) ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest {
	return ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		code: code,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinitionVersion
func (a *DefinitionsAPIService) ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeExecute(r ApiReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinitionVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.ReadDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions/{name}/languages-{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.resourceLanguageCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource.language.code", r.resourceLanguageCode, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveDefinitionsV1alpha1ResourceGroupRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	name string
	xAxwayTenantId *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiRemoveDefinitionsV1alpha1ResourceGroupRequest) XAxwayTenantId(xAxwayTenantId string) ApiRemoveDefinitionsV1alpha1ResourceGroupRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

func (r ApiRemoveDefinitionsV1alpha1ResourceGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveDefinitionsV1alpha1ResourceGroupExecute(r)
}

/*
RemoveDefinitionsV1alpha1ResourceGroup Remove ResourceGroup for version v1alpha1 from group definitions

Remove ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the ResourceGroup
 @return ApiRemoveDefinitionsV1alpha1ResourceGroupRequest
*/
func (a *DefinitionsAPIService) RemoveDefinitionsV1alpha1ResourceGroup(ctx context.Context, name string) ApiRemoveDefinitionsV1alpha1ResourceGroupRequest {
	return ApiRemoveDefinitionsV1alpha1ResourceGroupRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) RemoveDefinitionsV1alpha1ResourceGroupExecute(r ApiRemoveDefinitionsV1alpha1ResourceGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.RemoveDefinitionsV1alpha1ResourceGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveDefinitionsV1alpha1ResourceGroupAccessControlListRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiRemoveDefinitionsV1alpha1ResourceGroupAccessControlListRequest) XAxwayTenantId(xAxwayTenantId string) ApiRemoveDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

func (r ApiRemoveDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r)
}

/*
RemoveDefinitionsV1alpha1ResourceGroupAccessControlList Remove AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Remove AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the AccessControlList
 @return ApiRemoveDefinitionsV1alpha1ResourceGroupAccessControlListRequest
*/
func (a *DefinitionsAPIService) RemoveDefinitionsV1alpha1ResourceGroupAccessControlList(ctx context.Context, groupName string, name string) ApiRemoveDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	return ApiRemoveDefinitionsV1alpha1ResourceGroupAccessControlListRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) RemoveDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r ApiRemoveDefinitionsV1alpha1ResourceGroupAccessControlListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.RemoveDefinitionsV1alpha1ResourceGroupAccessControlList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiRemoveDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) XAxwayTenantId(xAxwayTenantId string) ApiRemoveDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

func (r ApiRemoveDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r)
}

/*
RemoveDefinitionsV1alpha1ResourceGroupCommandLineInterface Remove CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Remove CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the CommandLineInterface
 @return ApiRemoveDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest
*/
func (a *DefinitionsAPIService) RemoveDefinitionsV1alpha1ResourceGroupCommandLineInterface(ctx context.Context, groupName string, name string) ApiRemoveDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	return ApiRemoveDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) RemoveDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r ApiRemoveDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.RemoveDefinitionsV1alpha1ResourceGroupCommandLineInterface")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) XAxwayTenantId(xAxwayTenantId string) ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

func (r ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r)
}

/*
RemoveDefinitionsV1alpha1ResourceGroupResourceDefinition Remove ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Remove ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the ResourceDefinition
 @return ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest
*/
func (a *DefinitionsAPIService) RemoveDefinitionsV1alpha1ResourceGroupResourceDefinition(ctx context.Context, groupName string, name string) ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	return ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) RemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.RemoveDefinitionsV1alpha1ResourceGroupResourceDefinition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) XAxwayTenantId(xAxwayTenantId string) ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

func (r ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r)
}

/*
RemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion Remove ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Remove ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the ResourceDefinitionVersion
 @return ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest
*/
func (a *DefinitionsAPIService) RemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion(ctx context.Context, groupName string, name string) ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	return ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
func (a *DefinitionsAPIService) RemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r ApiRemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.RemoveDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1ResourceGroup *DefinitionsV1alpha1ResourceGroup
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceGroup resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupRequest) DefinitionsV1alpha1ResourceGroup(definitionsV1alpha1ResourceGroup DefinitionsV1alpha1ResourceGroup) ApiUpdateDefinitionsV1alpha1ResourceGroupRequest {
	r.definitionsV1alpha1ResourceGroup = &definitionsV1alpha1ResourceGroup
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupRequest) Execute() (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroup Update ResourceGroup for version v1alpha1 from group definitions

Update ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the ResourceGroup
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroup(ctx context.Context, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceGroup
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupRequest) (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1AccessControlList *DefinitionsV1alpha1AccessControlList
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.AccessControlList resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest) DefinitionsV1alpha1AccessControlList(definitionsV1alpha1AccessControlList DefinitionsV1alpha1AccessControlList) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	r.definitionsV1alpha1AccessControlList = &definitionsV1alpha1AccessControlList
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest) Execute() (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupAccessControlList Update AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Update AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the AccessControlList
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupAccessControlList(ctx context.Context, groupName string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1AccessControlList
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupAccessControlListExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListRequest) (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1AccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupAccessControlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1AccessControlList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	extension string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1AccessControlList *DefinitionsV1alpha1AccessControlList
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.AccessControlList resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) DefinitionsV1alpha1AccessControlList(definitionsV1alpha1AccessControlList DefinitionsV1alpha1AccessControlList) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest {
	r.definitionsV1alpha1AccessControlList = &definitionsV1alpha1AccessControlList
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) Execute() (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtension Update Extension resource data of AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Update Extension resource data of AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param extension Name of the extension
 @param name The name of the AccessControlList
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtension(ctx context.Context, groupName string, extension string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		extension: extension,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1AccessControlList
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtensionRequest) (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1AccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupAccessControlListExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists/{name}/{extension}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension"+"}", url.PathEscape(parameterValueToString(r.extension, "extension")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1AccessControlList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1AccessControlList *DefinitionsV1alpha1AccessControlList
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.AccessControlList resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) DefinitionsV1alpha1AccessControlList(definitionsV1alpha1AccessControlList DefinitionsV1alpha1AccessControlList) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest {
	r.definitionsV1alpha1AccessControlList = &definitionsV1alpha1AccessControlList
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) Execute() (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguages Update Languages data for AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Update Languages data for AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the AccessControlList
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguages(ctx context.Context, groupName string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1AccessControlList
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesRequest) (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1AccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists/{name}/languages"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1AccessControlList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	code string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1AccessControlList *DefinitionsV1alpha1AccessControlList
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.AccessControlList resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) DefinitionsV1alpha1AccessControlList(definitionsV1alpha1AccessControlList DefinitionsV1alpha1AccessControlList) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest {
	r.definitionsV1alpha1AccessControlList = &definitionsV1alpha1AccessControlList
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) Execute() (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCode Update Languages data for AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

Update Languages data for AccessControlList for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param code Language code.
 @param name The name of the AccessControlList
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCode(ctx context.Context, groupName string, code string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		code: code,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1AccessControlList
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCodeRequest) (*DefinitionsV1alpha1AccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1AccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupAccessControlListLanguagesCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/accesscontrollists/{name}/languages-{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1AccessControlList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1CommandLineInterface *DefinitionsV1alpha1CommandLineInterface
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.CommandLineInterface resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) DefinitionsV1alpha1CommandLineInterface(definitionsV1alpha1CommandLineInterface DefinitionsV1alpha1CommandLineInterface) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	r.definitionsV1alpha1CommandLineInterface = &definitionsV1alpha1CommandLineInterface
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) Execute() (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterface Update CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Update CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the CommandLineInterface
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterface(ctx context.Context, groupName string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1CommandLineInterface
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceRequest) (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1CommandLineInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1CommandLineInterface
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	extension string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1CommandLineInterface *DefinitionsV1alpha1CommandLineInterface
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.CommandLineInterface resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) DefinitionsV1alpha1CommandLineInterface(definitionsV1alpha1CommandLineInterface DefinitionsV1alpha1CommandLineInterface) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest {
	r.definitionsV1alpha1CommandLineInterface = &definitionsV1alpha1CommandLineInterface
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) Execute() (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtension Update Extension resource data of CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Update Extension resource data of CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param extension Name of the extension
 @param name The name of the CommandLineInterface
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtension(ctx context.Context, groupName string, extension string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		extension: extension,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1CommandLineInterface
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtensionRequest) (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1CommandLineInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines/{name}/{extension}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension"+"}", url.PathEscape(parameterValueToString(r.extension, "extension")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1CommandLineInterface
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1CommandLineInterface *DefinitionsV1alpha1CommandLineInterface
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.CommandLineInterface resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) DefinitionsV1alpha1CommandLineInterface(definitionsV1alpha1CommandLineInterface DefinitionsV1alpha1CommandLineInterface) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest {
	r.definitionsV1alpha1CommandLineInterface = &definitionsV1alpha1CommandLineInterface
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) Execute() (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguages Update Languages data for CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Update Languages data for CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the CommandLineInterface
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguages(ctx context.Context, groupName string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1CommandLineInterface
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesRequest) (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1CommandLineInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines/{name}/languages"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1CommandLineInterface
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	code string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1CommandLineInterface *DefinitionsV1alpha1CommandLineInterface
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.CommandLineInterface resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) DefinitionsV1alpha1CommandLineInterface(definitionsV1alpha1CommandLineInterface DefinitionsV1alpha1CommandLineInterface) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest {
	r.definitionsV1alpha1CommandLineInterface = &definitionsV1alpha1CommandLineInterface
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) Execute() (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCode Update Languages data for CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

Update Languages data for CommandLineInterface for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param code Language code.
 @param name The name of the CommandLineInterface
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCode(ctx context.Context, groupName string, code string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		code: code,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1CommandLineInterface
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCodeRequest) (*DefinitionsV1alpha1CommandLineInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1CommandLineInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupCommandLineInterfaceLanguagesCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/commandlines/{name}/languages-{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1CommandLineInterface
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	extension string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1ResourceGroup *DefinitionsV1alpha1ResourceGroup
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceGroup resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest) DefinitionsV1alpha1ResourceGroup(definitionsV1alpha1ResourceGroup DefinitionsV1alpha1ResourceGroup) ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest {
	r.definitionsV1alpha1ResourceGroup = &definitionsV1alpha1ResourceGroup
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest) Execute() (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupExtensionExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupExtension Update Extension resource data of ResourceGroup for version v1alpha1 from group definitions

Update Extension resource data of ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param extension Name of the extension
 @param name The name of the ResourceGroup
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupExtension(ctx context.Context, extension string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest{
		ApiService: a,
		ctx: ctx,
		extension: extension,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceGroup
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupExtensionExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupExtensionRequest) (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{name}/{extension}"
	localVarPath = strings.Replace(localVarPath, "{"+"extension"+"}", url.PathEscape(parameterValueToString(r.extension, "extension")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1ResourceGroup *DefinitionsV1alpha1ResourceGroup
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceGroup resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest) DefinitionsV1alpha1ResourceGroup(definitionsV1alpha1ResourceGroup DefinitionsV1alpha1ResourceGroup) ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest {
	r.definitionsV1alpha1ResourceGroup = &definitionsV1alpha1ResourceGroup
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest) Execute() (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupLanguagesExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupLanguages Update Languages data for ResourceGroup for version v1alpha1 from group definitions

Update Languages data for ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the ResourceGroup
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupLanguages(ctx context.Context, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceGroup
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupLanguagesExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesRequest) (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{name}/languages"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	code string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1ResourceGroup *DefinitionsV1alpha1ResourceGroup
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceGroup resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) DefinitionsV1alpha1ResourceGroup(definitionsV1alpha1ResourceGroup DefinitionsV1alpha1ResourceGroup) ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest {
	r.definitionsV1alpha1ResourceGroup = &definitionsV1alpha1ResourceGroup
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) Execute() (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupLanguagesCode Update Languages data for ResourceGroup for version v1alpha1 from group definitions

Update Languages data for ResourceGroup for version v1alpha1 from group definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param code Language code.
 @param name The name of the ResourceGroup
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupLanguagesCode(ctx context.Context, code string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest{
		ApiService: a,
		ctx: ctx,
		code: code,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceGroup
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupLanguagesCodeRequest) (*DefinitionsV1alpha1ResourceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupLanguagesCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{name}/languages-{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1ResourceDefinition *DefinitionsV1alpha1ResourceDefinition
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinition resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) DefinitionsV1alpha1ResourceDefinition(definitionsV1alpha1ResourceDefinition DefinitionsV1alpha1ResourceDefinition) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	r.definitionsV1alpha1ResourceDefinition = &definitionsV1alpha1ResourceDefinition
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) Execute() (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupResourceDefinition Update ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Update ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the ResourceDefinition
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinition(ctx context.Context, groupName string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinition
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionRequest) (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	extension string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1ResourceDefinition *DefinitionsV1alpha1ResourceDefinition
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinition resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) DefinitionsV1alpha1ResourceDefinition(definitionsV1alpha1ResourceDefinition DefinitionsV1alpha1ResourceDefinition) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest {
	r.definitionsV1alpha1ResourceDefinition = &definitionsV1alpha1ResourceDefinition
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) Execute() (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtension Update Extension resource data of ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Update Extension resource data of ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param extension Name of the extension
 @param name The name of the ResourceDefinition
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtension(ctx context.Context, groupName string, extension string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		extension: extension,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinition
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtensionRequest) (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources/{name}/{extension}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension"+"}", url.PathEscape(parameterValueToString(r.extension, "extension")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1ResourceDefinition *DefinitionsV1alpha1ResourceDefinition
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinition resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) DefinitionsV1alpha1ResourceDefinition(definitionsV1alpha1ResourceDefinition DefinitionsV1alpha1ResourceDefinition) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest {
	r.definitionsV1alpha1ResourceDefinition = &definitionsV1alpha1ResourceDefinition
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) Execute() (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguages Update Languages data for ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Update Languages data for ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the ResourceDefinition
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguages(ctx context.Context, groupName string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinition
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesRequest) (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources/{name}/languages"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	code string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1ResourceDefinition *DefinitionsV1alpha1ResourceDefinition
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinition resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) DefinitionsV1alpha1ResourceDefinition(definitionsV1alpha1ResourceDefinition DefinitionsV1alpha1ResourceDefinition) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest {
	r.definitionsV1alpha1ResourceDefinition = &definitionsV1alpha1ResourceDefinition
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) Execute() (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCode Update Languages data for ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

Update Languages data for ResourceDefinition for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param code Language code.
 @param name The name of the ResourceDefinition
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCode(ctx context.Context, groupName string, code string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		code: code,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinition
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCodeRequest) (*DefinitionsV1alpha1ResourceDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionLanguagesCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resources/{name}/languages-{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1ResourceDefinitionVersion *DefinitionsV1alpha1ResourceDefinitionVersion
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinitionVersion resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec, {extension}, languages, languages-{code}. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) DefinitionsV1alpha1ResourceDefinitionVersion(definitionsV1alpha1ResourceDefinitionVersion DefinitionsV1alpha1ResourceDefinitionVersion) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	r.definitionsV1alpha1ResourceDefinitionVersion = &definitionsV1alpha1ResourceDefinitionVersion
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) Execute() (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion Update ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Update ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the ResourceDefinitionVersion
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion(ctx context.Context, groupName string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinitionVersion
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionRequest) (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinitionVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceDefinitionVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	extension string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1ResourceDefinitionVersion *DefinitionsV1alpha1ResourceDefinitionVersion
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinitionVersion resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) DefinitionsV1alpha1ResourceDefinitionVersion(definitionsV1alpha1ResourceDefinitionVersion DefinitionsV1alpha1ResourceDefinitionVersion) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest {
	r.definitionsV1alpha1ResourceDefinitionVersion = &definitionsV1alpha1ResourceDefinitionVersion
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) Execute() (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtension Update Extension resource data of ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Update Extension resource data of ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param extension Name of the extension
 @param name The name of the ResourceDefinitionVersion
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtension(ctx context.Context, groupName string, extension string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		extension: extension,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinitionVersion
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtensionRequest) (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinitionVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions/{name}/{extension}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension"+"}", url.PathEscape(parameterValueToString(r.extension, "extension")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceDefinitionVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1ResourceDefinitionVersion *DefinitionsV1alpha1ResourceDefinitionVersion
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinitionVersion resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) DefinitionsV1alpha1ResourceDefinitionVersion(definitionsV1alpha1ResourceDefinitionVersion DefinitionsV1alpha1ResourceDefinitionVersion) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest {
	r.definitionsV1alpha1ResourceDefinitionVersion = &definitionsV1alpha1ResourceDefinitionVersion
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) Execute() (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguages Update Languages data for ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Update Languages data for ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param name The name of the ResourceDefinitionVersion
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguages(ctx context.Context, groupName string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinitionVersion
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesRequest) (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinitionVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions/{name}/languages"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceDefinitionVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest struct {
	ctx context.Context
	ApiService *DefinitionsAPIService
	groupName string
	code string
	name string
	xAxwayTenantId *string
	embed *string
	expand *string
	fields *string
	definitionsV1alpha1ResourceDefinitionVersion *DefinitionsV1alpha1ResourceDefinitionVersion
}

// The platform Organization ID. Not required when using Service Accounts.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) XAxwayTenantId(xAxwayTenantId string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest {
	r.xAxwayTenantId = &xAxwayTenantId
	return r
}

// Defines parameters that can be embedded:   * metadata.references - includes the referenced resources in the response.   * metadata.accessRights - includes user&#39;s permissions on requested resource and its scope.   * metadata.referencedByResources - includes counts for the resources referencing the current resource.   * metadata.scopedResources - includes counts for the resources scoped to the current resource. 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) Embed(embed string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest {
	r.embed = &embed
	return r
}

// Defines parameters that can be expanded:   * languages - expands the languages in the response.   * languages-* - expands the additional languages (\&quot;en-us\&quot;, \&quot;pt-br\&quot;, \&quot;de-de\&quot;, \&quot;fr-fr\&quot;) 
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) Expand(expand string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest {
	r.expand = &expand
	return r
}

// Query string for restricting the response fields from the definitions.v1alpha1.ResourceDefinitionVersion resource. Multiple values can be specified separated by comma. Supported values: group, apiVersion, kind, name, title, metadata, attributes, tags, spec. Unknown values will be ignored.
func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) Fields(fields string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest {
	r.fields = &fields
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) DefinitionsV1alpha1ResourceDefinitionVersion(definitionsV1alpha1ResourceDefinitionVersion DefinitionsV1alpha1ResourceDefinitionVersion) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest {
	r.definitionsV1alpha1ResourceDefinitionVersion = &definitionsV1alpha1ResourceDefinitionVersion
	return r
}

func (r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) Execute() (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	return r.ApiService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeExecute(r)
}

/*
UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCode Update Languages data for ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

Update Languages data for ResourceDefinitionVersion for version v1alpha1 from group definitions in scope ResourceGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName Name of the ResourceGroup
 @param code Language code.
 @param name The name of the ResourceDefinitionVersion
 @return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest
*/
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCode(ctx context.Context, groupName string, code string, name string) ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest {
	return ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		code: code,
		name: name,
	}
}

// Execute executes the request
//  @return DefinitionsV1alpha1ResourceDefinitionVersion
func (a *DefinitionsAPIService) UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeExecute(r ApiUpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCodeRequest) (*DefinitionsV1alpha1ResourceDefinitionVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DefinitionsV1alpha1ResourceDefinitionVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefinitionsAPIService.UpdateDefinitionsV1alpha1ResourceGroupResourceDefinitionVersionLanguagesCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/definitions/v1alpha1/groups/{groupName}/resourceversions/{name}/languages-{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupName"+"}", url.PathEscape(parameterValueToString(r.groupName, "groupName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAxwayTenantId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Axway-Tenant-Id", r.xAxwayTenantId, "")
	}
	// body params
	localVarPostBody = r.definitionsV1alpha1ResourceDefinitionVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiV1ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
